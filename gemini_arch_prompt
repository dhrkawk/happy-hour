You are assisting on the “Happy Hour” project. The current architecture intentionally prioritizes MVP speed, DB-side atomicity, and performance over strict Clean Architecture separation. Follow these rules:

1) Layer Responsibilities

Client “usecase” files = React Query Hooks (UI layer).

They call Next.js API routes (queryFn/mutationFn) and manage cache, loading/error.

They may transform API JSON/Entities into ViewModels via select/useMemo.

For management pages, they may return Entities directly (no VM).

API Routes (boundary).

Parse/validate request params (lightweight).

Call the Repository implementation directly (no server-side Usecase layer in MVP).

Repository Implementations (infra/supabase/repository).

Own both WHAT and HOW for frequently-used or transactional operations.

Call Supabase RPC for complex joins/aggregations/atomic writes.

Map DB Rows → Domain Entities, and return to API.

Supabase RPC (DB-side functions).

Encapsulate heavy/compound queries and transactional workflows.

Provide a single, optimized, atomic entry point for complex operations.

2) Data Flows

READ: Component → React Query Hook → API → Repo Impl → supabase.rpc(...) → DB
→ Repo maps Row→Entity → API returns JSON → Hook transforms to VM → Component renders.

WRITE: Component → React Query Mutation → API → Repo Impl → supabase.rpc(...) (transaction) → DB
→ Success/failure → Hook handles cache invalidation / toast.

3) Design Rationale

We deliberately let Repo Impl decide both WHAT and HOW for hot paths to:

reduce network round-trips,

guarantee atomicity for N+1 writes,

centralize complex joins/aggregations in RPC,

keep client hooks simple and productive for MVP.

Trade-offs acknowledged: domain/application separation is softer; DB coupling is higher; tests skew to integration.

4) Coding Patterns

Hook skeleton (READ)

export function useGetStoresWithEvents(onlyActive: boolean) {
  return useQuery({
    queryKey: ['stores','with-events',{ onlyActive }],
    queryFn: () => jsonFetch(`/api/stores?onlyActive=${onlyActive ? '1' : '0'}`),
    select: (payload) => buildStoreListVMs(extractRows(payload)),
    staleTime: 30_000, refetchOnWindowFocus: false,
  });
}


API Route skeleton

export async function GET(req: NextRequest) {
  const sb = await createClient();
  const repo = new SupabaseStoreRepository(sb);
  const onlyActive = parseBool(new URL(req.url).searchParams.get('onlyActive'));
  const result = await repo.getStoresWithEvents({ onlyActive });
  return NextResponse.json(result);
}


Repo Impl skeleton (with RPC & mapping)

async getStoreWithEventsAndMenusByStoreId(id: Id, opts?: { onlyActiveEvents?: boolean }) {
  const { data, error } = await this.sb.rpc('store_with_events_and_menus', {
    p_store_id: id,
    p_only_active_events: !!opts?.onlyActiveEvents,
  });
  if (error) throw error;
  const payload = data as RpcStoreWithEventsAndMenus;
  return {
    store:  Store.fromRow(payload.store),
    events: (payload.events ?? []).map(Event.fromRow),
    menus:  (payload.menus  ?? []).map(StoreMenu.fromRow),
  };
}


ViewModel rule of thumb

Single-source fetch → transform in select.

Multi-source composition → transform after all queries (e.g., useMemo with enrichment).

5) Vocabulary

“usecase hook” = React Query-based client hook (not server Usecase).

Repo Impl = Infra adapter that calls Supabase (including RPC) and maps Row→Entity.

RPC = DB function used for complex joins/aggregations/atomic writes.

6) Guardrails

Do not introduce a separate server-side Usecase layer unless strictly needed.

When performance or atomicity is key, prefer RPC and place the combined logic in the Repo Impl.

Keep hooks cohesive: one hook per UI use case, own the cache key and VM shaping.